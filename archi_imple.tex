\section{Architecture et implémentation du logiciel}

Maintenant que nous avons vu les outils utilisés pour réaliser simulationRainOfMusic, nous allons présenter son architecture et les éléments importants de son implémentation.

\subsection{Architecture}



\subsection{Implémentation}

Dans cette partie, nous allons présenter simulationRainOfMusic en s'intéressant d'un peu plus près au code qui permettent de remplir les trois objectifs principaux: la visualisation, la communication et la simulation.

\subsubsection{Visualisation}

mise en place de la scène 3D très facilement avec une classe camera déjà toute prête dans openFrameworks (\verb|EasyCam|)

possibilité de rajouter des axes x y z en plus pour mieux situer le robot dans l'espace

avec la souris, possibilité de se déplacer et de zoomer dans la scène 3D 

importation de modèle 3D pour représenter les metabots

sélection des robots, affichage d'informations relatives au robot sélectionné (identifiant et type du robot, position et fréquence pour les metabots)

affichage de messages warning pour les robots qui rentrent en collision et la zone de colliison est indiquée à l'aide d'un cercle rouge dans la scène

ajout d'une interface pour visualiser/modifier les positions et les vitesses via des sliders, visualiser s'il y a des collisions ou non, lancer la chorégraphie (boutton play)

\subsubsection{Communication}

La communication avec i-score est possible grâce à l'API d'OSSIA et à la classe \verb|Network|. Cette dernière permet d'initier la communication avec i-score. A la construction d'un objet Network, on lance l'exécution d'une fonction sur un thread qui fait la publication: elle déclare le programme comme un objet réseau, que l'on peut ajouter dans i-score en lui donnant son nom et le numéro de port associé, et qui constitue la racine de l'arbre du réseau. Elle envoie ensuite sur le réseau le noeud 'scène' en le déclarant comme noeud fils du programme.

A l'instanciation d'un robot, celui-ci est ajouté à l'arbre du réseau comme fils du noeud 'scène'. Chacun de ses attributs est aussi publié. Lorsqu'un attribut dans l'arbre publié sur le réseau est modifié via l'interface utilisateur d'i-score, sa valeur est mise à jour dans simulationRainOfMusic grâce à une fonction \verb|Callback|).

Pour ajouter la communication entre simulationRainOfMusic et son interface, la classe \verb|Parameter| a été créee. Elle encapsule la classe \verb|ofParameter| de openFrameworks. La classe \verb|ofParameter| permet de lier un listener à une valeur. Le listener permet de lier la valeur contenue dans \verb|ofParameter| à une autre fonction qui permet de mettre à jour cette valeur. Par exemple, un ofParameter peut être utilisé pour lier une valeur position en x avec un slider dans l'interface utilisateur : le fait de bouger le slider va mettre à jour la valeur représentant la position en x. De cette façon, utiliser une variable de type \verb|ofParameter| permet de lier un attribut de robot à l'interface utilisateur. 

Ainsi, la classe \verb|Parameter| encapsulant \verb|ofParameter| utilise un listener \verb|Callback| vers i-score et un listener vers l'interface de simulationRainOfMusic.

\subsubsection{Simulation}

détection de collision manuelle : bibliothèques graphiques ne compilaient pas lors de l'implémentation de la collision (Bullet)...

