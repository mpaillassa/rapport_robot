\section{Réalisation du logiciel}

Maintenant que nous avons vu les outils utilisés pour réaliser simulationRainOfMusic, nous allons présenter son architecture et les éléments importants de son implémentation.

\subsection{Architecture}
Dans les premières étapes de la réalisation du logiciel, nous avons établi l'architecture en respectant certains points qui nous paraissaient essentiels à ntore projet.

Tout d'abord, notre logiciel étant un logiciel de visualisation avant tout, il nous semblait plus clair de choisir une architecture modèle-vue. Cela nous permettait d'avoir une séparation nette entre la partie données des robots et la partie modélisation et affichage 3D. 

Ensuite, sachant que le projet contient des robots Metabot mais aussi drones, il nous avait été demandé à ce que notre logiciel soit modulaire, facilitant ainsi l'ajout de nouvaux types de robots. C'est pour cela que nous avons choisi dans notre implémentation d'utiliser le mécanisme en C++ des \verb|template| pour assurer ce côté modulaire.

Enfin, une attention particulière a été portée à la classe \verb|Parameter|, jouant le rôle d'intermédiaire entre i-score et l'interface utilisateur de notre logiciel. Cette classe occupe une place importante dans le projet puisqu'elle permet de mettre à jour les valeurs en fonction des modifications apportées à notre interface et à i-score.

Par ailleurs, l'intégration de la classe \verb|Parameter| dans l'architecture s'est déroulée naturellement : elle prend le rôle du contrôleur qui met à jour les valeurs du modèle en fonction des données modifiées sur la vue qui est aussi l'interface utilisateur.

		
\subsection{Implémentation}

Dans cette partie, nous allons présenter simulationRainOfMusic en s'intéressant d'un peu plus près au code qui permettent de remplir les trois objectifs principaux: la visualisation, la communication et la simulation.

\subsubsection{Visualisation}

La mise en place de la scène 3D se fait assez facilement car la caméra est déjà implémentée dans openFrameworks avec la classe (\verb|EasyCam|). L'utilisateur a la possibilité de se déplacer et de zoomer dans la scène 3D grâce à la souris. Les robots sont représentés par des modèles 3D.

L'utilisateur peut également sélectionner un robot. Lorsq'un robot est sélectionné, différentes caractéristiques le concernant s'affichent en haut à gauche de la fenêtre de simulation. Ces caractéristiques sont son identifiant, son type (métabot ou drone) et sa position. La sélection se fait en détectant la couleur du robot.

Si deux robots risquent de rentrer en collision, ceux-ci sont entourés d'un cercle rouge afin que ce soit bien visible.

En plus de ces informations, un onglet permet de visualiser et de modifier les positions et vitesses des robots via des sliders. Un emplacement dans l'onglet affiche également si les robots sont en collision ou pas. Une fois des vitesses choisies, un bouton play permet de voir la chorégraphie.


possibilité de rajouter des axes x y z en plus pour mieux situer le robot dans l'espace

\subsubsection{Communication}

La communication avec i-score est possible grâce à l'API d'OSSIA et à la classe \verb|Network|. Cette dernière permet d'initier la communication avec i-score. A la construction d'un objet Network, on lance l'exécution d'une fonction sur un thread qui fait la publication: elle déclare le programme comme un objet réseau, que l'on peut ajouter dans i-score en lui donnant son nom et le numéro de port associé, et qui constitue la racine de l'arbre du réseau. Elle envoie ensuite sur le réseau le noeud 'scène' en le déclarant comme noeud fils du programme.

A l'instanciation d'un robot, celui-ci est ajouté à l'arbre du réseau comme fils du noeud 'scène'. Chacun de ses attributs est aussi publié. Lorsqu'un attribut dans l'arbre publié sur le réseau est modifié via l'interface utilisateur d'i-score, sa valeur est mise à jour dans simulationRainOfMusic grâce à une fonction (\verb|Callback|).

Pour ajouter la communication entre simulationRainOfMusic et son interface, la classe \verb|Parameter| a été créee. Elle encapsule la classe \verb|ofParameter| de openFrameworks. La classe \verb|ofParameter| permet de lier un listener vers l'interface à une valeur. Le listener est une fonctionnalité qui permet d'être constamment à l'écoute de toute modification opérée au niveau de l'interface. Par exemple, un ofParameter peut être utilisé pour lier une valeur position en x avec un slider dans l'interface utilisateur : le fait de bouger le slider va mettre à jour la valeur représentant la position en x. De cette façon, utiliser une variable de type \verb|ofParameter| permet de lier un attribut de robot à l'interface utilisateur. 

Ainsi, la classe \verb|Parameter| encapsulant \verb|ofParameter| utilise un listener \verb|Callback| vers i-score et un listener vers l'interface de simulationRainOfMusic.


\subsubsection{Simulation}

détection de collision manuelle : bibliothèques graphiques ne compilaient pas lors de l'implémentation de la collision (Bullet)...

